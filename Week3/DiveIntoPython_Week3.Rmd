---
title: "Dive into Python Week 3"
author: "darthaline"
date: "28 Sept 2020"
output:
  html_notebook:
    toc: true
---

# Week 3
```{r}
library(reticulate)
```

## Classes

Data types we've learned about previously are classes in python.

We can use `type` to check the class of an object:

```{python}
num = 13.0
print(type(num))
```

### `isinstance` function

Function `isinstance` allows to check if the object belongs to a certain class:

```{python}
num = 13
isinstance(num, int)

numbers = {}
isinstance(numbers, dict)
```

We can define class as follows:

```{python}
class Human:
    pass #does nothing
#or
class Robot:
    """This class allows to make robots""" #documentation

print(Robot)

print(dir(Robot))
```

Even newly created classes have quite a few pre-defined methods.

Let's create a class `Planet`, and an object of this class `planet`

```{python}
class Planet:
    pass
    
planet = Planet()
print(planet)
```

We can create a list of `Planet` class objectS:

```{python}
solar_system = []
for i in range(8):
    planet = Planet()
    solar_system.append(planet)

print(solar_system) 
```

Class instances are hashable, so we can use them as keys in a dictionary:

```{python}
solar_system = {}
for i in range(8):
    planet = Planet()
    solar_system[planet] = True

print(solar_system)
```

The way we've defined the objects in the list means that none of the planets have their own names/specific properties. We can redefine those using method `__init__`:

```{python}
class Planet:
    def __init__(self, name):
        self.name = name

earth = Planet("Earth")
print(earth.name)
print(earth)

```

To make `print` of the class object more meaningful we can redefine method `__str__`

```{python}
class Planet:
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return self.name


earth = Planet("Earth")
print(earth)
```

So now we can apply that to a list:

```{python}
solar_system = []

planet_names = [
    "Mercury", "Venus", "Earth", "Mars", 
    "Jupiter", "Saturn", "Uranus", "Neptune"
]

for name in planet_names:
    planet = Planet(name)
    solar_system.append(planet)

print(solar_system)
```

Unfortunately defining them in a list invokes another method __repr__. To fix this we can do the following:

```{python}
class Planet:
    
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return f"Planet {self.name}"
        
solar_system = []

planet_names = [
    "Mercury", "Venus", "Earth", "Mars", 
    "Jupiter", "Saturn", "Uranus", "Neptune"
]

for name in planet_names:
    planet = Planet(name)
    solar_system.append(planet)

print(solar_system)
```

### Class attributes

We can also modify the attributes of a class:

```{python}
mars = Planet("Mars")
print(mars)

mars.name

mars.name = "Second Earth?"
mars.name
```

If the attribute doesn't exist, we'll get an error:
```{python}
mars.mass
```

Similar thing would happen if we delete the attribute and then refer to it:

```{python}
del mars.name

mars.name
```

We can define class attributes, which are variables belonging to the class itself, rather than to its objects:

```{python}
class Planet:
    count = 0
    def __init__(self, name, population=None):
        self.name = name
        self.population = population or []
        Planet.count += 1
earth = Planet("Earth")
mars = Planet("Mars")

print(Planet.count)
mars.count
```

### Class destructor

Method __del__ is a destructor of the class, and we can redefine it, however it's best to avoid it, and use other methods.

```{python}
class Human:

    def __del__(self):
        print("Goodbye!")

human = Human()
del human
```

### Class dictionary

We can call a dictionary of a class by using method `__dict__` on the object:

```{python}
class Planet:
    """This class describes planets"""
    
    count = 1
    
    def __init__(self, name, population=None):
        self.name = name
        self.population = population or []


planet = Planet("Earth")
planet.__dict__

planet.mass = 5.97e24
planet.__dict__
```

Similarly we can get a dict of the class itself.

```{python}
Planet.__dict__
```

We can call class documentation either through the object or a class itself:

```{python}
Planet.__doc__
planet.__doc__
```

To get the class from the object we can use method `__class__`

```{python}
planet.__class__
```

### Class constructor

Method `__new__` is a constructor of the class object. Here we redefine `__new__` and `__init__` to give us messages indicating when they are called:

```{python}
class Planet:

    def __new__(cls, *args, **kwargs):
        print("__new__ called")
        obj = super().__new__(cls)
        return obj

    def __init__(self, name):
        print("__init__ called")
        self.name = name
        
earth = Planet("Earth")
```

When we called Planet("Earth"), it called function new, which checked that the object being created is of the right type, and then called `__init__`

